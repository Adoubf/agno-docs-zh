---
title: åšå®¢æ–‡ç« ç”Ÿæˆå™¨
---
è¿™ä¸ªé«˜çº§ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•æ„å»ºä¸€ä¸ªç»“åˆç½‘ç»œç ”ç©¶èƒ½åŠ›ä¸ä¸“ä¸šå†™ä½œæŠ€å·§çš„å¤æ‚åšå®¢æ–‡ç« ç”Ÿæˆå™¨ã€‚è¯¥å·¥ä½œæµé‡‡ç”¨å¤šé˜¶æ®µæ–¹æ³•ï¼š
1. æ™ºèƒ½ç½‘ç»œç ”ç©¶ä¸æ¥æºæ”¶é›†
2. å†…å®¹æå–ä¸å¤„ç†
3. å¸¦è§„èŒƒå¼•ç”¨çš„ä¸“ä¸šåšå®¢æ–‡ç« æ’°å†™

æ ¸å¿ƒèƒ½åŠ›ï¼š
- é«˜çº§ç½‘ç»œç ”ç©¶ä¸æ¥æºè¯„ä¼°
- å†…å®¹æŠ“å–ä¸å¤„ç†
- æœç´¢å¼•æ“ä¼˜åŒ–çš„ä¸“ä¸šå†™ä½œ
- è‡ªåŠ¨å†…å®¹ç¼“å­˜æå‡æ•ˆç‡
- æ¥æºæ ‡æ³¨ä¸äº‹å®æ ¸éªŒ

å¯å°è¯•çš„ç¤ºä¾‹åšå®¢ä¸»é¢˜ï¼š
- "é€šç”¨äººå·¥æ™ºèƒ½çš„å´›èµ·ï¼šæœ€æ–°çªç ´"
- "é‡å­è®¡ç®—å¦‚ä½•é©æ–°ç½‘ç»œå®‰å…¨"
- "2024å¯æŒç»­ç”Ÿæ´»ï¼šå‡å°‘ç¢³è¶³è¿¹çš„å®ç”¨æŠ€å·§"
- "æœªæ¥å·¥ä½œæ–¹å¼ï¼šAIä¸äººç±»åä½œ"
- "å¤ªç©ºæ—…æ¸¸ï¼šä»ç§‘å¹»èµ°å‘ç°å®"
- "æ•°å­—æ—¶ä»£çš„æ­£å¿µä¸å¿ƒç†å¥åº·"
- "ç”µåŠ¨æ±½è½¦çš„è¿›åŒ–ï¼šç°çŠ¶ä¸æœªæ¥è¶‹åŠ¿"

è¿è¡Œ `pip install openai duckduckgo-search newspaper4k lxml_html_clean sqlalchemy agno` å®‰è£…ä¾èµ–é¡¹ã€‚

```python blog_post_generator.py
import json
from textwrap import dedent
from typing import Dict, Iterator, Optional

from agno.agent import Agent
from agno.models.openai import OpenAIChat
from agno.storage.sqlite import SqliteStorage
from agno.tools.duckduckgo import DuckDuckGoTools
from agno.tools.newspaper4k import Newspaper4kTools
from agno.utils.log import logger
from agno.utils.pprint import pprint_run_response
from agno.workflow import RunEvent, RunResponse, Workflow
from pydantic import BaseModel, Field


class NewsArticle(BaseModel):
    title: str = Field(..., description="Title of the article.")
    url: str = Field(..., description="Link to the article.")
    summary: Optional[str] = Field(
        ..., description="Summary of the article if available."
    )


class SearchResults(BaseModel):
    articles: list[NewsArticle]


class ScrapedArticle(BaseModel):
    title: str = Field(..., description="Title of the article.")
    url: str = Field(..., description="Link to the article.")
    summary: Optional[str] = Field(
        ..., description="Summary of the article if available."
    )
    content: Optional[str] = Field(
        ...,
        description="Full article content in markdown format. None if content is unavailable.",
    )


class BlogPostGenerator(Workflow):
    """Advanced workflow for generating professional blog posts with proper research and citations."""

    description: str = dedent("""\
    An intelligent blog post generator that creates engaging, well-researched content.
    This workflow orchestrates multiple AI agents to research, analyze, and craft
    compelling blog posts that combine journalistic rigor with engaging storytelling.
    The system excels at creating content that is both informative and optimized for
    digital consumption.
    """)

    # æœç´¢æ™ºèƒ½ä½“ï¼šè´Ÿè´£æ™ºèƒ½ç½‘ç»œæœç´¢åŠæ¥æºæ”¶é›†
    searcher: Agent = Agent(
        model=OpenAIChat(id="gpt-4o-mini"),
        tools=[DuckDuckGoTools()],
        description=dedent("""\
        You are BlogResearch-X, an elite research assistant specializing in discovering
        high-quality sources for compelling blog content. Your expertise includes:

        - Finding authoritative and trending sources
        - Evaluating content credibility and relevance
        - Identifying diverse perspectives and expert opinions
        - Discovering unique angles and insights
        - Ensuring comprehensive topic coverage\
        """),
        instructions=dedent("""\
        1. Search Strategy ğŸ”
           - Find 10-15 relevant sources and select the 5-7 best ones
           - Prioritize recent, authoritative content
           - Look for unique angles and expert insights
        2. Source Evaluation ğŸ“Š
           - Verify source credibility and expertise
           - Check publication dates for timeliness
           - Assess content depth and uniqueness
        3. Diversity of Perspectives ğŸŒ
           - Include different viewpoints
           - Gather both mainstream and expert opinions
           - Find supporting data and statistics\
        """),
        response_model=SearchResults,
    )

    # å†…å®¹æŠ“å–å™¨ï¼šæå–å¹¶å¤„ç†æ–‡ç« å†…å®¹
    article_scraper: Agent = Agent(
        model=OpenAIChat(id="gpt-4o-mini"),
        tools=[Newspaper4kTools()],
        description=dedent("""\
        You are ContentBot-X, a specialist in extracting and processing digital content
        for blog creation. Your expertise includes:

        - Efficient content extraction
        - Smart formatting and structuring
        - Key information identification
        - Quote and statistic preservation
        - Maintaining source attribution\
        """),
        instructions=dedent("""\
        1. Content Extraction ğŸ“‘
           - Extract content from the article
           - Preserve important quotes and statistics
           - Maintain proper attribution
           - Handle paywalls gracefully
        2. Content Processing ğŸ”„
           - Format text in clean markdown
           - Preserve key information
           - Structure content logically
        3. Quality Control âœ…
           - Verify content relevance
           - Ensure accurate extraction
           - Maintain readability\
        """),
        response_model=ScrapedArticle,
    )

    # å†…å®¹æ’°å†™æ™ºèƒ½ä½“ï¼šæ ¹æ®ç ”ç©¶åˆ›ä½œå¼•äººå…¥èƒœçš„åšå®¢æ–‡ç« 
    writer: Agent = Agent(
        model=OpenAIChat(id="gpt-4o"),
        description=dedent("""\
        You are BlogMaster-X, an elite content creator combining journalistic excellence
        with digital marketing expertise. Your strengths include:

        - Crafting viral-worthy headlines
        - Writing engaging introductions
        - Structuring content for digital consumption
        - Incorporating research seamlessly
        - Optimizing for SEO while maintaining quality
        - Creating shareable conclusions\
        """),
        instructions=dedent("""\
        1. Content Strategy ğŸ“
           - Craft attention-grabbing headlines
           - Write compelling introductions
           - Structure content for engagement
           - Include relevant subheadings
        2. Writing Excellence âœï¸
           - Balance expertise with accessibility
           - Use clear, engaging language
           - Include relevant examples
           - Incorporate statistics naturally
        3. Source Integration ğŸ”
           - Cite sources properly
           - Include expert quotes
           - Maintain factual accuracy
        4. Digital Optimization ğŸ’»
           - Structure for scanability
           - Include shareable takeaways
           - Optimize for SEO
           - Add engaging subheadings\
        """),
        expected_output=dedent("""\
        # {ç—…æ¯’å¼ä¼ æ’­æ ‡é¢˜}

        # # ç®€ä»‹
        {Engaging hook and context}

        # # {å¼•äººæ³¨ç›®çš„ç¬¬ä¸€éƒ¨åˆ†}
        {Key insights and analysis}
        {Expert quotes and statistics}

        # # {å¼•äººå…¥èƒœçš„ç¬¬äºŒéƒ¨åˆ†}
        {Deeper exploration}
        {Real-world examples}

        # # {å®è·µç¯èŠ‚ 3}
        {Actionable insights}
        {Expert recommendations}

        # # æ ¸å¿ƒè¦ç‚¹
        - {Shareable insight 1}
        - {Practical takeaway 2}
        - {Notable finding 3}

        # # æ•°æ®æº
        {Properly attributed sources with links}\
        """),
        markdown=True,
    )

    def run(
        self,
        topic: str,
        use_search_cache: bool = True,
        use_scrape_cache: bool = True,
        use_cached_report: bool = True,
    ) -> Iterator[RunResponse]:
        logger.info(f"Generating a blog post on: {topic}")

        # å¦‚æœ use_cache ä¸º True åˆ™ä½¿ç”¨ç¼“å­˜çš„åšå®¢æ–‡ç« 
        if use_cached_report:
            cached_blog_post = self.get_cached_blog_post(topic)
            if cached_blog_post:
                yield RunResponse(
                    content=cached_blog_post, event=RunEvent.workflow_completed
                )
                return

        # åœ¨ç½‘ç»œä¸Šæœç´¢ä¸ä¸»é¢˜ç›¸å…³çš„æ–‡ç« 
        search_results: Optional[SearchResults] = self.get_search_results(
            topic, use_search_cache
        )
        # å¦‚æœæœªæ‰¾åˆ°è¯¥ä¸»é¢˜çš„æœç´¢ç»“æœï¼Œåˆ™ç»ˆæ­¢å·¥ä½œæµç¨‹
        if search_results is None or len(search_results.articles) == 0:
            yield RunResponse(
                event=RunEvent.workflow_completed,
                content=f"Sorry, could not find any articles on the topic: {topic}",
            )
            return

        # æŠ“å–æœç´¢ç»“æœ
        scraped_articles: Dict[str, ScrapedArticle] = self.scrape_articles(
            topic, search_results, use_scrape_cache
        )

        # ä¸ºæ’°å†™è€…å‡†å¤‡è¾“å…¥ææ–™
        writer_input = {
            "topic": topic,
            "articles": [v.model_dump() for v in scraped_articles.values()],
        }

        # è¿è¡Œå†™å…¥å™¨å¹¶è¿”å›å“åº”
        yield from self.writer.run(json.dumps(writer_input, indent=4), stream=True)

        # å°†åšå®¢æ–‡ç« ä¿å­˜åˆ°ç¼“å­˜ä¸­
        self.add_blog_post_to_cache(topic, self.writer.run_response.content)

    def get_cached_blog_post(self, topic: str) -> Optional[str]:
        logger.info("Checking if cached blog post exists")

        return self.session_state.get("blog_posts", {}).get(topic)

    def add_blog_post_to_cache(self, topic: str, blog_post: str):
        logger.info(f"Saving blog post for topic: {topic}")
        self.session_state.setdefault("blog_posts", {})
        self.session_state["blog_posts"][topic] = blog_post

    def get_cached_search_results(self, topic: str) -> Optional[SearchResults]:
        logger.info("Checking if cached search results exist")
        search_results = self.session_state.get("search_results", {}).get(topic)
        return (
            SearchResults.model_validate(search_results)
            if search_results and isinstance(search_results, dict)
            else search_results
        )

    def add_search_results_to_cache(self, topic: str, search_results: SearchResults):
        logger.info(f"Saving search results for topic: {topic}")
        self.session_state.setdefault("search_results", {})
        self.session_state["search_results"][topic] = search_results

    def get_cached_scraped_articles(
        self, topic: str
    ) -> Optional[Dict[str, ScrapedArticle]]:
        logger.info("Checking if cached scraped articles exist")
        scraped_articles = self.session_state.get("scraped_articles", {}).get(topic)
        return (
            ScrapedArticle.model_validate(scraped_articles)
            if scraped_articles and isinstance(scraped_articles, dict)
            else scraped_articles
        )

    def add_scraped_articles_to_cache(
        self, topic: str, scraped_articles: Dict[str, ScrapedArticle]
    ):
        logger.info(f"Saving scraped articles for topic: {topic}")
        self.session_state.setdefault("scraped_articles", {})
        self.session_state["scraped_articles"][topic] = scraped_articles

    def get_search_results(
        self, topic: str, use_search_cache: bool, num_attempts: int = 3
    ) -> Optional[SearchResults]:
        # å¦‚æœuse_search_cacheä¸ºTrueï¼Œåˆ™ä»ä¼šè¯çŠ¶æ€ä¸­è·å–ç¼“å­˜çš„search_results
        if use_search_cache:
            try:
                search_results_from_cache = self.get_cached_search_results(topic)
                if search_results_from_cache is not None:
                    search_results = SearchResults.model_validate(
                        search_results_from_cache
                    )
                    logger.info(
                        f"Found {len(search_results.articles)} articles in cache."
                    )
                    return search_results
            except Exception as e:
                logger.warning(f"Could not read search results from cache: {e}")

        # è‹¥æ— ç¼“å­˜çš„æœç´¢è®°å½•ï¼ˆsearch_resultsï¼‰ï¼Œåˆ™ä½¿ç”¨æœç´¢å™¨ï¼ˆsearcherï¼‰æŸ¥æ‰¾æœ€æ–°æ–‡ç« ã€‚
        for attempt in range(num_attempts):
            try:
                searcher_response: RunResponse = self.searcher.run(topic)
                if (
                    searcher_response is not None
                    and searcher_response.content is not None
                    and isinstance(searcher_response.content, SearchResults)
                ):
                    article_count = len(searcher_response.content.articles)
                    logger.info(
                        f"Found {article_count} articles on attempt {attempt + 1}"
                    )
                    # ç¼“å­˜æœç´¢ç»“æœ
                    self.add_search_results_to_cache(topic, searcher_response.content)
                    return searcher_response.content
                else:
                    logger.warning(
                        f"Attempt {attempt + 1}/{num_attempts} failed: Invalid response type"
                    )
            except Exception as e:
                logger.warning(f"Attempt {attempt + 1}/{num_attempts} failed: {str(e)}")

        logger.error(f"Failed to get search results after {num_attempts} attempts")
        return None

    def scrape_articles(
        self, topic: str, search_results: SearchResults, use_scrape_cache: bool
    ) -> Dict[str, ScrapedArticle]:
        scraped_articles: Dict[str, ScrapedArticle] = {}

        # å¦‚æœ use_scrape_cache ä¸º Trueï¼Œåˆ™ä»ä¼šè¯çŠ¶æ€è·å–ç¼“å­˜çš„ scraped_articles
        if use_scrape_cache:
            try:
                scraped_articles_from_cache = self.get_cached_scraped_articles(topic)
                if scraped_articles_from_cache is not None:
                    scraped_articles = scraped_articles_from_cache
                    logger.info(
                        f"Found {len(scraped_articles)} scraped articles in cache."
                    )
                    return scraped_articles
            except Exception as e:
                logger.warning(f"Could not read scraped articles from cache: {e}")

        # æŠ“å–æœªåœ¨ç¼“å­˜ä¸­çš„æ–‡ç« 
        for article in search_results.articles:
            if article.url in scraped_articles:
                logger.info(f"Found scraped article in cache: {article.url}")
                continue

            article_scraper_response: RunResponse = self.article_scraper.run(
                article.url
            )
            if (
                article_scraper_response is not None
                and article_scraper_response.content is not None
                and isinstance(article_scraper_response.content, ScrapedArticle)
            ):
                scraped_articles[article_scraper_response.content.url] = (
                    article_scraper_response.content
                )
                logger.info(f"Scraped article: {article_scraper_response.content.url}")

        # å°†æŠ“å–çš„æ–‡ç« ä¿å­˜åœ¨ä¼šè¯çŠ¶æ€ä¸­
        self.add_scraped_articles_to_cache(topic, scraped_articles)
        return scraped_articles


# å½“è„šæœ¬è¢«ç›´æ¥æ‰§è¡Œæ—¶è¿è¡Œå·¥ä½œæµç¨‹
if __name__ == "__main__":
    import random

    from rich.prompt import Prompt

    # å±•ç¤ºç”Ÿæˆå™¨å¤šåŠŸèƒ½æ€§çš„è¶£å‘³ç¤ºä¾‹æç¤º
    example_prompts = [
        "Why Cats Secretly Run the Internet",
        "The Science Behind Why Pizza Tastes Better at 2 AM",
        "Time Travelers' Guide to Modern Social Media",
        "How Rubber Ducks Revolutionized Software Development",
        "The Secret Society of Office Plants: A Survival Guide",
        "Why Dogs Think We're Bad at Smelling Things",
        "The Underground Economy of Coffee Shop WiFi Passwords",
        "A Historical Analysis of Dad Jokes Through the Ages",
    ]

    # è·å–ç”¨æˆ·çš„ä¸»é¢˜
    topic = Prompt.ask(
        "[bold]Enter a blog post topic[/bold] (or press Enter for a random example)\nâœ¨",
        default=random.choice(example_prompts),
    )

    # å°†ä¸»é¢˜è½¬æ¢ä¸º URL å®‰å…¨çš„å­—ç¬¦ä¸²ï¼Œç”¨äº session_id
    url_safe_topic = topic.lower().replace(" ", "-")

    # åˆå§‹åŒ–åšå®¢æ–‡ç« ç”Ÿæˆå™¨å·¥ä½œæµ
    # - åŸºäºä¸»é¢˜åˆ›å»ºå”¯ä¸€çš„ä¼šè¯ID
    # - è®¾ç½® SQLite å­˜å‚¨ç”¨äºç¼“å­˜ç»“æœ
    generate_blog_post = BlogPostGenerator(
        session_id=f"generate-blog-post-on-{url_safe_topic}",
        storage=SqliteStorage(
            table_name="generate_blog_post_workflows",
            db_file="tmp/agno_workflows.db",
        ),
        debug_mode=True,
    )

    # å¯ç”¨ç¼“å­˜æ‰§è¡Œå·¥ä½œæµ
    # è¿”å›ä¸€ä¸ªåŒ…å«ç”Ÿæˆå†…å®¹çš„ RunResponse å¯¹è±¡è¿­ä»£å™¨
    blog_post: Iterator[RunResponse] = generate_blog_post.run(
        topic=topic,
        use_search_cache=True,
        use_scrape_cache=True,
        use_cached_report=True,
    )

    # æ‰“å°å“åº”
    pprint_run_response(blog_post, markdown=True)
```

## ä½¿ç”¨æ–¹æ³•

<Steps>
  <Snippet file="create-venv-step.mdx" />

  <Step title="å®‰è£…åº“">
    ```bash
    openai duckduckgo-search newspaper4k lxml_html_clean sqlalchemy agno
    ```
  </Step>

  <Step title="è¿è¡Œå·¥ä½œæµ">
    ```bash
    python blog_post_generator.py
    ```
  </Step>

</Steps>